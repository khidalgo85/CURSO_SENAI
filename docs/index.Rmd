---
title: "Curso de Gen√¥mica e Metagen√¥mica"
subtitle: "Linhas de Comando e Ferramentas On-Line"
author: Dra. Kelly Hidalgo
institute: SENAI
date: "Nov 2023 - Jan 2024"
aspectratio: 169 # 16:9
#classoption: handout
output:
  xaringan::moon_reader:
    css: xaringan-themer.css
    nature:
      highlightStyle: github
      highlightLines: true
      navigation:
        scroll: false
---

<div style = "position:fixed; visibility: hidden">
$$\require{color}\definecolor{yellow}{rgb}{1, 0.8, 0.16078431372549}$$
$$\require{color}\definecolor{orange}{rgb}{0.96078431372549, 0.525490196078431,
0.203921568627451}$$ $$\require{color}\definecolor{green}{rgb}{0,
0.474509803921569, 0.396078431372549}$$
$$\require{color}\definecolor{blue}{rgb}{0, 0, 205}$$
$$\require{color}\definecolor{red}{rgb}{255, 0, 0}$$ </div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
    Macros: {
      yellow: ["{\\color{yellow}{#1}}", 1],
      orange: ["{\\color{orange}{#1}}", 1],
      green: ["{\\color{green}{#1}}", 1],
      blue: ["{\\color{blue}{#1}}", 1],
      red: ["{\\color{red}{#1}}", 1]
    },
    loader: {load: ['[tex]/color']},
    tex: {packages: {'[+]': ['color']}}
  }
});
</script>
<style> .yellow {color: #FFCC29;} .orange {color: #F58634;} .green {color:
#007965;} .blue {color: #0000CD;} .red {color: #FF0000;} </style>
```{r xaringan-logo1, echo=FALSE}
library(xaringan)
library(xaringanExtra)
library(emo)
library(knitr)
```
```{r setup commen, include=FALSE}
knitr::opts_chunk$set(comment="")
```
```{css, echo = FALSE}
.huge .remark-code { /*Change made here*/
  font-size: 150% !important;
}
.tiny .remark-code { /*Change made here*/
  font-size: 60% !important;
}
```
```{r update1, eval = FALSE, echo=FALSE}
xaringan::inf_mr()
```
```{r share-again, echo=FALSE}
xaringanExtra::use_share_again()
```
```{r update, eval = FALSE, echo=FALSE}
xaringan::inf_mr()
```
```{r xaringanExtra-clipboard, echo=FALSE}
htmltools::tagList(
  xaringanExtra::use_clipboard(
    button_text = "<i class=\"fa fa-clipboard\"></i>",
    success_text = "<i class=\"fa fa-check\" style=\"color: #90BE6D\"></i>",
    error_text = "<i class=\"fa fa-times-circle\" style=\"color: #F94144\"></i>"
  ),
  rmarkdown::html_dependency_font_awesome()
)
```
```{r xaringan-extra-styles, echo=FALSE}
xaringanExtra::use_extra_styles(
  hover_code_line = TRUE,         #<<
  mute_unhighlighted_code = TRUE  #<<
)
```
```{r xaringanExtra, echo = FALSE}
xaringanExtra::use_progress_bar(color = "#0051BA", location = "top")
```
```{r xaringan-tile-view, echo=FALSE}
xaringanExtra::use_tile_view()
```
```{r xaringan-editable, echo=FALSE}
xaringanExtra::use_editable(expires = 1)
```
```{r xaringan-scribble, echo=FALSE}
xaringanExtra::use_scribble()
```
```{r xaringan-panelset, echo=FALSE}
xaringanExtra::use_panelset()
```
```{r flair_color, echo=FALSE}
library(flair)
yellow <- "#FFCC29"
orange <- "#F58634"
green <- "#007965"
blue <- "#0000CD"
```
---
## Um pouco sobre mim
* Nome: Kelly Hidalgo Martinez
* `r emo::ji("colombia")` Sou da Col√¥mbia `r emo::ji("colombia")`
* Sou microbiologista
* Doutora em gen√©tica e biologia molecular da Unicamp
* Grupo de Ecologia Microbiana e Multi-√¥micas da Divis√£o de Recursos Microbianos do CPQBA- UNICAMP
* √Årea de pesquisa: Microbiomas de √°reas contaminadas com petr√≥leo e derivados
```{r qrcode, echo=FALSE, fig.align = 'right', out.width = "30%"}
knitr::include_graphics("03.Images/ORCID.png")
```
---
## Conte√∫do Program√°tico
**1. Sequenciamento de √°cidos nucleicos**

|   1.1. Hist√≥rico

|   1.2. Sanger

|   1.3. Next Generation Sequence

|   1.4. Sequenciamento por s√≠ntese

|   1.5. Detec√ß√£o de √≠ons de hidrog√™nio

|   1.6. Sequenciamento por nanoporos

|   1.7. Estrat√©gia de Sequenciamento foco: Gen√¥mica e Metagen√¥mica
---
## Conte√∫do Program√°tico

**2. No√ß√µes de linguagem de programa√ß√£o**

|   2.1. Sistema Operacional - GNU/LINUX

|       2.1.1. Linha de comando (Comandos b√°sicos)

|       2.1.2. Instala√ß√£o de ferramentas con Anaconda/Miniconda
---
## Conte√∫do Program√°tico

**3. Estrat√©gias de An√°lises Gen√≥micas ‚Äì Command Line Interface (CLI)**

|   3.1. Controle de Qualidade

|   3.2. Montagem de novo

|   3.3. Avalia√ß√£o da Montagem

|   3.4. Anota√ß√£o Taxon√¥mica

|   3.5. Anota√ß√£o Funcional

|   3.6. Predi√ß√£o de ORFs

|   3.7. Atribui√ß√£o Funcional das ORFs

|   3.8. Aplica√ß√µes
---
## Conte√∫do Program√°tico

**4. Estrat√©gias de An√°lises Gen√≥micas ‚Äì Graphical User Interface (GUI)**

|   4.1. KBase

|       4.1.2. Controle de qualidade

|       4.1.3. Trimagem e Filtragem de sequ√™ncias

|       4.1.4. Motagem de novo

|       4.1.5. Avalia√ß√£o de montagem

|       4.1.6. Anota√ß√£o taxon√¥mica

|       4.1.7. Anota√ß√£o funcional

|   4.2. Introdu√ß√£o a RAPT

|       4.2.1. Montagem de novo com Skesa

|       4.2.2. Anota√ß√£o Taxon√¥mica (ANI)

|       4.2.3. Anota√ß√£o Funcional (PGAP)
---
## Conte√∫do Program√°tico

**5. Estrat√©gias de An√°lises Metagen√≥micas ‚Äì Command Line Interface (CLI)**

|   5.1. Avalia√ß√£o da qualidade

|   5.2. Cobertura dos Metagenoma

|   5.3. An√°lise de Dist√¢ncias MinHash (abordagem de co-assembly)

|   5.4. Montagem dos Metagenomas

|   5.5. Controle de Qualidade das montagens

|   5.6. Predi√ß√£o das ORFs (Open Reading Frame)

|   5.7. Anota√ß√£o Funcional

|   5.8. Anota√ß√£o Taxon√¥mica

|   5.9. Mapeamento
---
## Conte√∫do Program√°tico

|   5.10. Recupera√ß√£o de MAGs (Metagenome Assembled Genomes)

|   5.11. An√°lises Downstream

|       5.11.1. R Software

|       5.11.2. RawGraphs.io

---

**6. Estrat√©gias de An√°lises Metagen√≥micas ‚Äì Graphical User Interface (GUI)**

|   6.1. MGRAST

|   6.2. Kbase

**7. Bonus: Python**

|   7.1. Conceitos b√°sicos

---
class: center, middle, inverse
.huge[ # Antes de come√ßar lembremos juntos conceitos b√°sicos ]
---
## Lembrando a estrutura do DNA (√Åcido desoxirribonucleico)
* √â a mol√©cula que carrega toda a informa√ß√£o gen√©tica dos organismos.
* Tem uma estrutura qu√≠mica simples
.center[ ![dna](https://media.giphy.com/media/YRzQnWzbn4WIxd3ZYx/giphy.gif) ]

---
## Estrutura do DNA
```{r, echo=FALSE, fig.align = 'center', out.width = "70%"}
knitr::include_graphics("03.Images/DNA.png")
```
* A mol√©cula de DNA est√° composta por nucleot√≠deos

---
## Estrutura do DNA
* Os nucleot√≠deos tamb√©m s√£o conhecidos como dNTPs - desoxinucleot√≠deo.
* O grupo fosfato d√° o carater negativo √† mol√©cula de DNA.
* O a√ß√∫car √© uma pentosa (cinco carbonos), chamado desoxirribose, pela falta do oxig√™nio no carbono 2.
```{r, echo=FALSE, fig.align = 'center', out.width = "50%"}
knitr::include_graphics("03.Images/dntps1.png")
```
```{r, echo=FALSE, fig.align = 'center', out.width = "50%"}
knitr::include_graphics("03.Images/ribosa.png")
```
---
## Estrutura do DNA
* As bases d√£o nome aos nucleot√≠deos.
* Existem dois tipos de bases nitrogenadas, purinas e pirimidinas.
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/bases.png")
```
---
## Estrutura do DNA
* As bases nitrogenadas s√£o complementares e se ligam por pontes de hidrog√™nio (uni√£o da dupla fita).
* Sempre se d√° a uni√£o entre A e T por duas pontes, e entre G e C por tr√™s pontes.
* A liga√ß√£o GC √© mais forte.
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/GCAT.png")
```
---
## Estrutura do DNA
* A polimeriza√ß√£o da fita de DNA, se d√° por uma liga√ß√£o 3'-5' fosfodi√©ster.
```{r, echo=FALSE, fig.align = 'center', out.width = "70%"}
knitr::include_graphics("03.Images/fita.png")
```
---
## Estrutura do DNA
* Dupla fita, antiparalela.
```{r, echo=FALSE, fig.align = 'center', out.width = "55%"}
knitr::include_graphics("03.Images/duplafita.png")
```
---
## Dogma Central da Biologia Molecular
.center[ ![dna](https://media.giphy.com/media/mRI1hW0ZBVUly/giphy.gif) ]
* O DNA se duplica, sempre em sentido 5' --> 3'
* O DNA √© transcrito em RNA mensageiro e estes traduzidos em prote√≠nas

---
class: center, middle, inverse
.huge[ # Agora sim entrando no nosso curso... ]
---

class: inverse, center, middle
.huge[ # 1. Sequenciamento de DNA e RNA ]
---

## O que √© sequenciamento?
√â a utiliza√ß√£o de m√©todos bioqu√≠micos para determinar a ordem dos nucleotideos
em uma mol√©cula de DNA ou RNA. Assim, ser√° poss√≠vel conhecer a sequ√™ncia em que
as quatro bases nucleot√≠dicas ocorrem.
.center[ ![dna](https://media.giphy.com/media/YlmI36YAWe7KScC7hK/giphy.gif) ]
---
class: center, middle, inverse
.huge[ # Um pouco de hist√≥ria ]
---
## A viagem pela hist√≥ria do sequenciamento do DNA
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/history_1.png")
```
---
## A viagem pela hist√≥ria do sequenciamento do DNA
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/history_2.png")
```
---
## A viagem pela hist√≥ria do sequenciamento do DNA
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/history_3.png")
```
---
## A viagem pela hist√≥ria do sequenciamento do DNA
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/history_4.png")
```
---
## A viagem pela hist√≥ria do sequenciamento do DNA
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/history_5.png")
```
---
## A viagem pela hist√≥ria do sequenciamento do DNA
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/history_6.png")
```
---
## A viagem pela hist√≥ria do sequenciamento do DNA
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/history_7.png")
```
---
## A viagem pela hist√≥ria do sequenciamento do DNA
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/history_8.png")
```
---
## Evolu√ß√£o do custo do sequenciamento do genoma humano
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/cpg.png")
```
.tiny[
* Fonte: National Human Genome Research Institute
]

---
## Outros dados interessantes...
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/costs.png")
```
---
## Plataformas de sequenciamento
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/plataformas.png")
```
---
## Primeira Gera√ß√£o: T√©cnica Sanger
```{r, echo=FALSE, fig.align = 'center', out.width = "60%"}
knitr::include_graphics("03.Images/sanger2.jpg")
```
* M√©todo de terminaliza√ß√£o de cadeia
* Para isolados (n√£o amostras mistas)
* Fragmentos de ~800 bp (F/R at√© ~1500 bp)
* Primeira m√°quina da Applied Biosystems (1986)
* Usada por Craig Venter para acelarar o Projeto Genoma Humano

---
## Primeira Gera√ß√£o: T√©cnica Sanger
* A rea√ß√£o de sequenciamento √© muito similar a uma PCR
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/sanger3.png")
```
---
## Primeira Gera√ß√£o: T√©cnica Sanger
### dNTPs vs ddNTPs
* Ausen√ßa de um grupo 3'-hidroxil
```{r, echo=FALSE, fig.align = 'center', out.width = "80%"}
knitr::include_graphics("03.Images/dntps2.png")
```
---
## Primeira Gera√ß√£o: T√©cnica Sanger
### ddNTPs
* N√£o forma pontes fosfodi√©ster com outros dNTPs ou ddNTPs
```{r, echo=FALSE, fig.align = 'center', out.width = "70%"}
knitr::include_graphics("03.Images/dntps3.png")
```
---
## Primeria Gera√ß√£o: T√©cnica Sanger
* Cada ddNTP √© marcado com um fluor√≥foro diferente e emitir√° uma "cor" diferente quando exitado
```{r, echo=FALSE, fig.align = 'center', out.width = "60%"}
knitr::include_graphics("03.Images/dntps4.png")
```
---
## Primeria Gera√ß√£o: T√©cnica Sanger
```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
```
<iframe width="560" height="315"
src="https://www.youtube.com/embed/0ZVdROXCsi0?si=Wc9ryeKQvDwBgVof"
title="YouTube video player" frameborder="0" allow="accelerometer; autoplay;
clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
allowfullscreen></iframe>
---
## Primeria Gera√ß√£o: T√©cnica Sanger
### Interpreta√ß√£o dos resultados
* √ìtimo
  * Picos bem distribuidos
  * Cada pico uma cor s√≥
  * Altura dos picos pode variar 3 vezes
  * Ruido m√≠nimo
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/chromatogram1.jpeg")
```
---
## Primeria Gera√ß√£o: T√©cnica Sanger
### Interpreta√ß√£o dos resultados
* Aceit√°vel
  * Um pouco mais de ru√≠do
  * Picos bem distribu√≠dos
  * Cada pico uma cor s√≥
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/chromatogram2.jpeg")
```
---
## Primeria Gera√ß√£o: T√©cnica Sanger
### Interpreta√ß√£o dos resultados
* Reprovado
  * Muito ru√≠do
  * Picos de mais de uma cor nas posi√ß√µes 271, 273, 279
  * Algumas partes com picos desorganizados
  * Posi√ß√£o 310, n√£o √© claro qual √© o nucleot√≠deo real
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/chromatogram3.jpeg")
```
---
## Nova ou Segunda Gera√ß√£o
* Podem ser sequenciadas v√°rias mol√©culas de DNA (Paralelismo)
* Mais r√°pido
* Gera maior volume de dados
* Baixo custo
* Menor comprimento dos fragmentos (short-reads)
* Requer prepara√ß√£o de bibliotecas
* Necessidade de novos algoritmos para processamento dos dados

---
## Nova ou segunda gera√ß√£o: Ion Torrent
* Sequenciamento por s√≠nteses
* Similar ao pirosequenciamento (454 Roche)
* Detec√ß√£o dos nucleot√≠deos por mudan√ßas no pH (libera√ß√£o de protons)
* Uso de semicondutores como sensor
* Fragmetos de 200 a 600 bp
* *Single-end*
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/iontorrent.png")
```
---
## Nova ou segunda gera√ß√£o: Ion Torrent
```{r, echo=FALSE, fig.align = 'center', out.width = "70%"}
knitr::include_graphics("03.Images/iontorrent2.png")
```
---
## Nova ou segunda gera√ß√£o: Ion Torrent
<iframe width="560" height="315"
src="https://www.youtube.com/embed/ltHX21vUJb0?si=fVFiE7bsvWb5nUFW"
title="YouTube video player" frameborder="0" allow="accelerometer; autoplay;
clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
allowfullscreen></iframe>

---
## Nova ou segunda gera√ß√£o: Illumina

--
* Sequenciamento por s√≠nteses: identifica simultaneamente os nucleot√≠deos enquanto os incorpora na cadeia de DNA

--

* Nucleot√≠deos modificados, carregam um fluor√≥foro para serem detectados

--

* Os nucleot√≠deos tamb√©m posuem um terminador **revers√≠vel** que bloqueia a incorpora√ß√£o da pr√≥xima base

--

* Detec√ß√£o por fluorescencia

--

* Uma vez √© detectado o nucleot√≠deo que foi adicionada na cadeia, o terminador √© clivado para a pr√≥xima base possa se ligar e continuar o sequenciamento

--

* Maior custo-benef√≠cio: curto tempo de leitura, baixa taxa de erro e altamente escal√°vel.

--
* Na mais recente plataforma NovaSeq 6000, podem ser analisadas at√© 798 amostras simultaneamente

--

* *Single-end* (sequenciamento de uma das pontas dos fragmentos, uma leitura por fragmento) e *paired-end* (sequenciamento das duas pontas dos fragmentos, duas leituras por fragmento)

---
## Nova ou segunda gera√ß√£o: Illumina
### *Single-end*  vs. *Paired-end*
```{r, echo=FALSE, fig.align = 'center', out.width = "70%"}
knitr::include_graphics("03.Images/pairedend.png")
```
---
## Nova ou segunda gera√ß√£o: Illumina
### Prepara√ß√£o das bibliotecas (*paired-end*)
* Fragmenta√ß√£o aleat√≥ria do DNA (150 a 300 bp)
  * M√©todos f√≠sicos de fragmenta√ß√£o (ex. sonica√ß√£o e nebuliza√ß√£o)
  * M√©todos qu√≠micos (ex. enzimas de restri√ß√£o)
  **Este processo tem que ser o mais aleat√≥rio poss√≠vel**
* Liga√ß√£o dos *Barcodes* (v√°rias amostras simult√°neamente).
* Liga√ß√£o dos adaptadores nas extermidades de cada fragmento
  * Permitem se ligar aos adaptadores complementares numa placa de vidro (*flow cell*).
```{r, echo=FALSE, fig.align = 'center', out.width = "50%"}
knitr::include_graphics("03.Images/adaptadores.png")
```
---
## Nova ou segunda gera√ß√£o: Illumina
### Prepara√ß√£o dos clusters
* Cada fragmento se ligar√° √† placa por complementariedade dos adaptadores e gerar√° um cluster.
```{r, echo=FALSE, fig.align = 'center', out.width = "70%"}
knitr::include_graphics("03.Images/cluster.png")
```
---
## Nova ou segunda gera√ß√£o: Illumina
### Prepara√ß√£o dos clusters
* Cada sequencia pressa na placa ser√° amplificada por PCR gerando os *clusters*.
* Cada *cluster* cont√™m ~1 milh√£o de c√≥pias do mesmo fragemento
* Amplifica√ß√£o em ponte
```{r, echo=FALSE, fig.align = 'center', out.width = "55%"}
knitr::include_graphics("03.Images/cluster2.png")
```
---
## Nova ou segunda gera√ß√£o: Illumina
### Prepara√ß√£o dos clusters
* Cada sequencia pressa na placa ser√° amplificada por PCR gerando os *clusters*.
* Cada *cluster* cont√™m ~1 milh√£o de c√≥pias do mesmo fragemento
* Amplifica√ß√£o em ponte
```{r, echo=FALSE, fig.align = 'center', out.width = "55%"}
knitr::include_graphics("03.Images/cluster3.png")
```
---
## Nova ou segunda gera√ß√£o: Illumina
### Prepara√ß√£o dos clusters
* Cada sequencia pressa na placa ser√° amplificada por PCR gerando os *clusters*.
* Cada *cluster* cont√™m ~1 milh√£o de c√≥pias do mesmo fragemento
* Amplifica√ß√£o em ponte
```{r, echo=FALSE, fig.align = 'center', out.width = "50%"}
knitr::include_graphics("03.Images/cluster4.png")
```
---
## Nova ou segunda gera√ß√£o: Illumina
### Prepara√ß√£o dos clusters
* Cada sequencia pressa na placa ser√° amplificada por PCR gerando os *clusters*.
* Cada *cluster* cont√™m ~1 milh√£o de c√≥pias do mesmo fragemento
* Amplifica√ß√£o em ponte
```{r, echo=FALSE, fig.align = 'center', out.width = "60%"}
knitr::include_graphics("03.Images/cluster5.png")
```
---
## Nova ou segunda gera√ß√£o: Illumina
### Prepara√ß√£o dos clusters
* Cada sequencia pressa na placa ser√° amplificada por PCR gerando os *clusters*.
* Cada *cluster* cont√™m ~1 milh√£o de c√≥pias do mesmo fragemento
* Amplifica√ß√£o em ponte
```{r, echo=FALSE, fig.align = 'center', out.width = "60%"}
knitr::include_graphics("03.Images/cluster6.png")
```
---
## Nova ou segunda gera√ß√£o: Illumina
### Sequenciamento por s√≠nteses
* Os quatro nucleot√≠deos (*FI-NTPs*) s√£o adicionados ao mesmo tempo
* S√£o modificados, tem um fluor√≥foro diferente cada um e um bloqueador remov√≠vel no extremo 3'
```{r, echo=FALSE, fig.align = 'center', out.width = "3C 0%"}
knitr::include_graphics("03.Images/seq1.png")
```
---
## Nova ou segunda gera√ß√£o: Illumina
### Sequenciamento por s√≠nteses
* Os quatro nucleot√≠deos s√£o adicionados ao mesmo tempo
* S√£o modificados, tem um fluor√≥foro diferente cada um e um bloqueador remov√≠vel no extremo 3'
```{r, echo=FALSE, fig.align = 'center', out.width = "30%"}
knitr::include_graphics("03.Images/SEQ2.png")
```
---
## Nova ou segunda gera√ß√£o: Illumina
### Sequenciamento por s√≠nteses
* O laser excita o fluor√≥foro e o nucleot√≠deo adicionado √© detectado
```{r, echo=FALSE, fig.align = 'center', out.width = "50%"}
knitr::include_graphics("03.Images/seq3.png")
```
---
## Nova ou segunda gera√ß√£o: Illumina
### Sequenciamento por s√≠nteses
* O terminador e o fluor√≥foro s√£o clivados
```{r, echo=FALSE, fig.align = 'center', out.width = "40%"}
knitr::include_graphics("03.Images/seq4.png")
```
---
## Nova ou segunda gera√ß√£o: Illumina
### Sequenciamento por s√≠nteses
* O seguinte nucleot√≠deo √© adicionado
```{r, echo=FALSE, fig.align = 'center', out.width = "40%"}
knitr::include_graphics("03.Images/seq5.png")
```
---
## Nova ou segunda gera√ß√£o: Illumina
### Sequenciamento por s√≠ntese
* E o processo √© repitido at√© terminar de sintetizar o fragmento
```{r, echo=FALSE, fig.align = 'center', out.width = "50%"}
knitr::include_graphics("03.Images/seq6.png")
```
---
## Nova ou segunda gera√ß√£o: Illumina
### Sequenciamento por s√≠nteses
* Imagem obtida a cada ciclo
* A imagem √© transformada em bases (*basecalling*) e *reads* ou leituras.
* Sequenciamento *paired-reads* ger√° um arquivo por cada extremo (R1 e R2)
```{r, echo=FALSE, fig.align = 'center', out.width = "60%"}
knitr::include_graphics("03.Images/seq7.png")
```
---
## Nova ou segunda gera√ß√£o: Illumina
### Sequenciamento por s√≠nteses
```{r, echo=FALSE, fig.align = 'center', out.width = "70%"}
knitr::include_graphics("03.Images/seq8.gif")
```
---
## Nova ou segunda gera√ß√£o: Illumina
<iframe width="560" height="315"
src="https://www.youtube.com/embed/fCd6B5HRaZ8?si=fNvVsJ2TlvSaXl1X"
title="YouTube video player" frameborder="0" allow="accelerometer; autoplay;
clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
allowfullscreen></iframe>
---
## Nova ou segunda gera√ß√£o: Illumina
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/plataformasIllumina.png")
```
---
## Terceira gera√ß√£o: Oxford Nanopore
* *Long-reads* (~10 - 15 kbp). Facilita a montagem de genomas
* Sequenciamento de mol√©cula √∫nica (SMS): Dispensa as etapas de amplifica√ß√£o por PCR, nas tecnologias anteriores
* Sequenciamento em tempo real
* Precio do equipamento desde $1.000 USD
* Taxa de erro mais alta que Illumina (~10%)
* O fragmento de DNA passa por um nanoporo proteico

---
## Terceira gera√ß√£o: Oxford Nanopore
* A corrente i√¥nica sofre varia√ß√µes causadas pela liga√ß√£o de v√°rios nucleot√≠deos no mesmo poro
* As varia√ß√µes na corrente i√¥nica √© registrada em um modelo gr√°fico e interpretada para identificar a sequ√™ncia gerando leituras "1D" ou "2D" (quando s√£o lidas as duas fitas de DNA)
* O sequenciamento 1D, √© mais r√°pido, o protocolo mais simples e barato
* O sequenciamento 2D, mais demorado, por√©m sequencia com maior confiabilidade
```{r, echo=FALSE, fig.align = 'center', out.width = "50%"}
knitr::include_graphics("03.Images/minion.webp")
```
---
## Terceira gera√ß√£o: Oxford Nanopore
* A assinatura el√©trica detectada √© usada para inferir as bases presentes
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/poro.webp")
```
---
## Terceira gera√ß√£o: Oxford Nanopore
### Prepara√ß√£o das bibliotecas
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/minionprep.png")
```
---
## Terceira gera√ß√£o: Oxford Nanopore
<iframe width="560" height="315"
src="https://www.youtube.com/embed/iT_A_ucWMls?si=vE2FHAXMAJQOrErf"
title="YouTube video player" frameborder="0" allow="accelerometer; autoplay;
clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
allowfullscreen></iframe>
---
## Terceira gera√ß√£o: Oxford Nanopore
### Equipamentos
```{r, echo=FALSE, fig.align = 'center', out.width = "100%"}
knitr::include_graphics("03.Images/oxford.png")
```
---
## Que plataforma escolher?
```{r, echo=FALSE, fig.align = 'center', out.width = "80%"}
knitr::include_graphics("03.Images/comparison.png")
```
[Illumina](https://www.illumina.com/systems/sequencing-platforms/comparison-tool.html#/)
---
## Gen√¥mica vs Metagen√¥mica
**Gen√¥mica**
* Sequenciamento de um microrganismos isolado
* S√≥ cultiv√°veis
* Bioinform√°tica mais simples
**Metagen√¥mica**
* Sequenciamento do **DNA total** de uma amostra (ex. solo, agua, alimentos, biorreator)
* N√£o precisa m√©todos de cultivo
* Bioinform√°tica mais complexa

---
## At√© aqui aprendimos:
* Lembramos conceitos b√°sicos de biologia molecular, especialmente relacionados com a estrutura do DNA.
* Uma viagem pela hist√≥ria do sequenciamento at√© nossos dias
* Revis√£o das principais tecnologias de sequenciamento, os principios, m√©todos, vavntagens e disvantagens

---
class: center, middle, inverse
.huge[ # 2. No√ß√µes de linguagem de programa√ß√£o: Linux ]
---
## Neste m√≥dulo vamos aprender:
* Linux como ferramenta de trabalho
* L√≥gica de programa√ß√£o, o b√°sico do b√°sico para processar dados de gen√¥mica e metagen√¥mica
* Uso de ferramentas locais para an√°lise de seus dados

---
## Neste m√≥dulo **N√£o** vamos a aprender:
* Detalhes dos algoritmos utilizados
* Programa√ß√£o direta (A maioria dos *scripts* j√° est√£o prontos)

---
## Sistema Operacional - GNU/LINUX
* Software livre e de c√≥digo aberto
* A maioria das ferramentas de bioinform√°tica foram desenvolvidas para este sistema operacional
* Distribui√ß√£o mais famosa: *Ubuntu*
* Multitarefa
* Multiusu√°rio
.center[ ![dna](https://media.giphy.com/media/4N5ddOOJJ7gtKTgNac/giphy.gif) ]

---
## GUI vs CLI
* GUI: *Graphical User Interface*
  * Uso de teclado, mouse, voz.
  * Windows
  * Linux (sim tamb√©m tem GUI)
  * Dificil automatiza√ß√£o
  * Trabalho manual, maior possibilidade de erros
* CLI: *Command Line Interface*
  * Linha de comando (Tela preta + c√≥digos)
  * F√°cil automatiza√ß√£o
  * Maioria das ferramentas de bioinform√°tica usam linha de comando
  
---
## Shell
O *shell* do Linux √© um interpretador da linha de comando. √â uma ferramenta que
permite aos usu√°rios executar tarefas complexas e poderosas, geralmente com
algumas linhas de c√≥digo.
Usar o *shell* exigir√° algum esfor√ßo e algum tempo para aprender. Voc√™ ter√° que
praticar os comandos como novo vocabul√°rio de um idioma novo.
No entanto, aprendendo um pequeno n√∫mero de "palavras" (comandos), voc√™ ter√°
percorrido j√° um longo caminho. Essas poucas por√©m essenciais palavras s√£o as
que aprenderemos.
A gram√°tica de um *shell* permite combinar ferramentas existentes em pipelines
poderosos e lidar automaticamente com grandes volumes de dados.
Sequencias de comandos podem ser escritas em um *script*, melhorando a
reprodutibilidade dos fluxos de trabalho.
---
class: center, middle, inverse
# M√£os a obra
.center[ ![](https://media.giphy.com/media/MdA16VIoXKKxNE8Stk/giphy.gif) ]
---
## Abrindo o *shell*
* Abra o aplicativo Ubuntu subsystem
Quando o *shell* √© aberto, apresentar√° o que se conhece com *prompt*, o que
indica que o *shell* est√° pronto.
O *prompt* mais com√∫m √© `$`
Nos exemplos das aulas sempre aparecer√° primeiro o *prompt* `$`. N√£o √©
necess√°rio digitar o *prompt* quando fa√ßam comandos de exemplo. S√≥ digitem o que
est√° **depois** do *prompt*.
As vezes, antes do *prompt* pode ter outras informa√ß√µes como o nome do usu√°rio.
√â hora de tentar o primeiro comando...

---
## Mais antes uma informa√ß√£o importante...
Ao igual que o Windows ou o Mac, o Linux est√° organizado em diret√≥rios, portanto
todos os arquivos s√£o guardados nos diret√≥rios.
Depois a gente volta no conceito de estrutura dos diret√≥rios no Linux.
---
## Navegando por arquivos e diret√≥rios
O sistema respons√°vel pelo gerenciamento dos arquivos e os diret√≥rios √© chamado
de *file system*.
Organiza os nossos dados dentro de arquivos, que carregam a informa√ß√£o, e
diret√≥rios ou pastas, que carregam arquivos ou outros diret√≥rios.
A continua√ß√£o aprenderemos uma s√©rie de comandos que s√£o usados frequentemente
para criar, inspeccionar, renomear e deletar arquivos e diret√≥rios.
---
## `pwd` - *Print Working Directory*
.panelset[ .panel[.panel-name[`pwd`]
Os diret√≥rios s√£o como *lugares*, sempre que estamos usando o *shell*, estamos
exatamente em um lugar, chamado *current working directory* (diret√≥rio atual de
trabalho). Os comandos leem e gravam principalmente arquivos no diret√≥rio atual
de trabalho, ou seja, .yellow['aqui'], portanto √© importantye saber onde voc√™
est√° antes de executar um comando.
`pwd` mostra onde voc√™ esta:
.orange[Input] .code-bg-gray[
```
$ pwd
```
] .green[Output] .code-bg-gray[
```
/Users/macbook
```
] ]
.panel[.panel-name[Nota]
**Nota:** O caminho ao diret√≥rio atual pode aparecer diferente segundo o sistema operativo. Por exemplo em Linux pode ser `/home/macbook`, e em Windows, pode ser similar a `C:\Documents and Settigs\macbook` ou `C:\Users\macbook`. Isso pode variar inclusive entre vers√µes de Windows. Nos pr√≥ximo exemplos, usaremos o output de Mac como padr√£o. No Linux e Windows pode ser um pouquinho diferente.
]
.panel[.panel-name[Graficamente]
```{r, echo=FALSE, fig.align = 'center', out.width = "60%"}
knitr::include_graphics("03.Images/diretorios.png")
```
O sistema de arquivos do meu laptop, √© algo assim. O diret√≥rio mais para cima, √©
o chamado **root**, o qual tem todos os arquivos e pastas do meu laptop. Se
simboliza com a barra `/`. Essa barra √© a mesma que est√° no `/Users/macbook`.
Dentro do diret√≥rio *root*, tem outros diret√≥rios, como s√£o: `Applications`,
`bin`, `etc`, `home`, `Users`, etc.
Ent√£o, agora a gente sabe que o meu diret√≥rio atual de trabalho √©
`/Users/macbook` que est√° armazenado dentro `/Users`, porque `/Users` √© a
primeira parte do caminho. E assim, tamb√©m percebemos que `/Users` est√°
armazenado dentro do diret√≥rio *root* `/`, porque o caminho come√ßa com `/`. ]
.panel[.panel-name[Nota 2]
Note que a barra `/` tem dois significados. Quando aparece na frente de um
arquicvo o diret√≥rio se refere ao diret√≥rio *root*. Quando aparece entre o
caminho, √© um separador.
]
.panel[.panel-name[Explorando mais]
Explorando mais, a gente pode perceber que dentro de `/Users`, se encontram os
diret√≥rios, *Shared* e *macbook*.
```{r, echo=FALSE, fig.align = 'center', out.width = "70%"}
knitr::include_graphics("03.Images/diretorios2.png")
```
.blue[**Agora √© sua vez...**]
* Qual √© seu diret√≥rio de trabalho?
] ]

---
## `ls` - *list*
.panelset[ .panel[.panel-name[`ls`]
Agora sabemos qual √© nosso diret√≥rio atual, mas e como podemos acceder ao
conte√∫do deste diret√≥rio?. O comando `ls` listar√° o conte√∫do do diret√≥rio atual.
.orange[Input]
.code-bg-gray[
```
$ ls
```
]
.green[Output]
.code-bg-gray[
```
anaconda3 snap
```
] ] .panel[.panel-name[`ls -F`]
Comumente os comandos podem ser acompanhados por argumentos, mudando o
resultado. Por exemplo se usarmos o argumento `-F`, pede para o `ls` classificar
o conte√∫do do diret√≥rio pelo tipo de elemento, por exemplo, diret√≥rio, arquivo
ou execut√°vel. `/` : Diret√≥rio; `@` : √© um link; `*` : execut√°vel.
.orange[Input]
.code-bg-gray[
```
$ ls -F
```
]
.green[Output]
.code-bg-gray[
```
anaconda3/ snap/
```
] ] .panel[.panel-name[Dica!]
**Nota:** Se voc√™ quiser limpar o seu terminal (*shell*), digite o comando `clear`. Usando as zetas ‚¨ÜÔ∏è ‚¨áÔ∏è, podem ser recuperados linhas de comando digitadas anteriormente.
]
.panel[.panel-name[Ajuda]
Normalmente todos os comandos tem um men√∫ de ajuda, onde voc√™ pode ver qual √© a
fun√ß√£o desse comando e os argumentos que pode usar.
.orange[Input]
.code-bg-gray[
```
$ ls --help
```
]
.blue[**Agora √© sua vez...**]
* Liste o conte√∫do do seu diret√≥rio atual
* Acceda ao men√∫ de ajuda do comando `ls`
* Teste mais argumentos do comando `ls` (ex. `-r`, `-t`, `-l` e `-a`), e veja o que cada uma das op√ß√µes faz.
]
.panel[.panel-name[Explorando mais]
`ls` n√£o √© somente para usar no diret√≥rio atual, tamb√©m podem ser explorados
outros diret√≥rios.
D√™ uma olhada na pasta **anaconda3**, digitando `ls -F anaconda3`. Nesse exemplo
o comando √© `ls`, a op√ß√£o √© `-F` e o argumento √© `anaconda3`.
O argumento `anaconda3` diz para `ls` que queremos listar o conte√∫do de um
diret√≥rio diferente ao atual, no caso o diret√≥rio `anaconda3`
Se o diret√≥rio `anaconda3` n√£o existe no seu diret√≥rio atual, ser√° retornado um
erro. Normalmente, o diret√≥rio `anaconda3` existe dentro de seu diret√≥rio
`home`.
] ]

---
## Sintaxe geral dos comandos no shell
Normalmente, um comando se divide em: comando, op√ß√µes e argumentos.
.orange[Input]
.code-bg-gray[
```
$ ls -l Escritorio
```
]
```{r, echo=FALSE, fig.align = 'center', out.width = "60%"}
knitr::include_graphics("03.Images/sintaxe.png")
```
Tamb√©m podem ser encontradas op√ß√µes que al√©m de come√ßar com um tra√ßo simples
(`-`), conhecido como op√ß√£o curta, podem come√ßar com dois tra√ßos (`--`). As
op√ß√µes mudam o comportamneto do comando e os argumentos falam para o comando a
qual elemento ser√° aplicado o comando (p.e. arquivos e diret√≥rios). As vezes os
argumentos tamb√©m s√£o chamados param√™tros. Um comando pode ter mais de uma op√ß√£o
e mais de um argumento, por√©m n√£o sempre se requer um arguemnto ou uma op√ß√£o.
---
## `mkdir` - *Make Dir*
.panelset[ .panel[.panel-name[`mkdir`]
O comando `mkdir` serve para criar diret√≥rios.
Antes de criar o nosso primeiro diret√≥rio, primeiro revisemos as boas pr√°ticas
para nomear arquivos e diret√≥rios.
1. **N√£o** crie nomes com espa√ßos. `curso_senai` √© melhor que `curso senai` 2.
**N√£o** √© permitido o uso de caracteres especiais, como: $%&*()+=¬®;'?#@¬°! 3.
**N√£o** comece com `-`, os comandos tratam os nomes que como come√ßam com `-`
como as op√ß√µes 4. Coloque nomes que sejam indicativos do que o arquivo ou
diret√≥rio contem. `curso_senai` √© melhor que `curso` 5. **Recomenda√ß√£o:** para
trabalhos de passos sequenciais, facilita nomear os diret√≥rios com n√∫meros que
indiquem a etapa do trabalho. `00.DadosBrutos` melhor que `DadosBrutos`,
`01.Qualidade` melhor que `Qualidade` ]
.panel[.panel-name[Uso]
Criaremos um diret√≥rio para armazenar todo o relacionado ao curso. Esta ser√° sua
pasta durante o curso todo.
.orange[Input]
.code-bg-gray[
```
$ mkdir curso_senai
```
]
* Como confirmaria que o diret√≥rio foi criado?
]
.panel[.panel-name[Conceito:Caminho]
Uma vez criado o diret√≥rio do curso, criaremos uma pasta dentro dele para
armazenar o relacioanado a nossa aula de comandos b√°sicos de linux. Mas antes...
* Identifique onde voc√™ est√°?
Para conseguir criar o diret√≥rio dentro de `curso_senai`, primeiro temos que
aprender o conceito de **caminho**
O **caminho** de um diret√≥rio ou arquivo nada mais √© que a localiza√ß√£o completa
desse elemento. Por exemplo `/root/curso_senai`: A pasta `curso_senai`, est√°
dentro de `root` que a sua vez est√° dentro da pasta raiz `/`.
Existem **caminhos absolutos** e **caminhos relativos**. O exemplo anterior √© um
caminho absoluto. O caracter `~` √© interpretado por *shell* como o diret√≥rio
*home* do usuario, ou seja `~/curso_senai` √© o mesmo que `/root/curso_senai`,
porque o diret√≥rio *home* no nosso caso √© `/root/`.
]
.panel[.panel-name[Pr√°tica]
Entendido o conceito de caminho...
* Como criar um diret√≥rio dentro de outro?
.orange[Input]
.code-bg-gray[.can-edit[
```
$ mkdir
```
] ] ] ]
---
## `cd` - *Change Directory*
.panelset[ .panel[.panel-name[`cd`]
At√© agora j√° aprendimos como nos localizar dentro do sistema de arquivos, o que
√© caminho e como criar diret√≥rios, por√©m como entramos e saimos dos diret√≥rios?
O comando `cd` nos permite trocar entre diret√≥rios, basta s√≥ indicar o caminho
da pasta.
Por exemplo, estando no diret√≥rio *home*, queremos ir √† pasta que criamos
anteriormente `curso_senai`
.orange[Input]
.code-bg-gray[
```
$ cd curso_senai/
```
] ]
* Como voc√™ pode comprovar que mudou de diret√≥rio?
.panel[.panel-name[Atalhos]
Existem algumas conven√ß√µes para alguns diret√≥rios gen√©ricos.
* Diret√≥rio atual: `.`
* Diret√≥rio contenedor do diret√≥rio atual: `..`
**Dica de ouro**
Voc√™ pode usar a tecla **Tab** para autocompletar as palavras. Assim, economiza
tempo, e evita erros de escrita, porque o sistema s√≥ vai completar nomes de
elementos existentes no sistema. S√≥ tem que escrever as primeiras letras da
palavra e presionar tab, e o sistema autocompletar√° a palavra.
]
.panel[.panel-name[Pr√°tica]
.blue[**Agora √© sua vez...**]
* Onde voc√™ est√°?
* Liste o conte√∫do do seu diret√≥rio atual?
* Qual seria a linha de comando para entrar na pasta `comandos_basicos`.
* Como voltaria ao diret√≥rio contenedor de `comandos_basicos` ou seja `curso_senai`
.orange[Input]
.code-bg-gray[.can-edit[
```
$
```
] ] ] ]
---
class: inverse
## Quiz
Use o diagrama de embaixo, se `pwd` imprime na tela `/Users/thing`, que sair√°
usando a linha de comando `ls -F ../backup`?
1. `../backup: No such file or directory` 2. `2012-12-01 2013-01-08 2013-01-27`
3. `2012-12-01/ 2013-01-08/ 2013-01-27/` 4. `original/ pnas_final/ pnas_sub/`
```{r, echo=FALSE, fig.align = 'center', out.width = "60%"}
knitr::include_graphics("03.Images/exercicio1.jpg")
```
---
class: inverse
## Quiz
Estando no diret√≥rio `/root/curso_senai`, quais dos seguintes comando poderiamos
usar para navegar e chegar no diret√≥rio home, que √© `/root`?
1. `cd .` 2. `cd /` 3. `cd /root` 4. `cd ../..` 5. `cd ~` 6. `cd home` 7. `cd
~/curso_senai/..` 8. `cd` 9. `cd ..`
---
class: inverse
## Quiz
Use o diagrama de embaixo, se `pwd` imprime na tela `/Users/backup`, e -r diz
para o `ls` imprimir o nomes dos elementos em ordem reversa, qual ou quais
comandos daria o seguinte output:
.green[Output] .code-bg-gray[
```
pnas_sub/ pnas_final/ original/
```
]
```{r, echo=FALSE, fig.align = 'center', out.width = "45%"}
knitr::include_graphics("03.Images/exercicio2.jpg")
```
1. `ls pwd` 2. `ls -r -F` 3. `ls -r -F /Users/backup`
---
## `nano` - Editor de texto
.panelset[ .panel[.panel-name[`nano`]
`nano` √© um editor de texto, com o qual podemos criar ou editar arquivos planos.
.orange[Input]
.code-bg-gray[
```
$ nano teste.txt
```
]
Para este curso vamos usar `nano` porque √© um dos editores de texto plano mais
simples de usar. No entanto por essa mesma raz√£o ele n√£o √© t√£o podereso e
flex√≠vel. Existem outros para Linux, como
[**Emacs**](https://www.gnu.org/software/emacs/) e
[**Vim**](https://www.vim.org/), por√©m ambos precisam de mais tempo para
aprender us√°-los. Em Windows, pode ser usado **Notepad++**
]
.panel[.panel-name[Pr√°tica]
.blue[**Agora √© sua vez...**]
* Se necess√°rio use o comando `cd` para entrar na pasta `comandos_b√°sicos`
* Crie um arquivo chamado `teste.txt`. Escreva dentro do arquivo: `Ol√° Mundo`
* Para sair do editor pressione ctrl + x, ele vai perguntar se voc√™ quer gravar, pressione S ou Y. Depois ele vai perguntar se quer manter o nome, se sim √© s√≥ pressionar Enter.
* Descarregue os arquivos: `propanol.txt`, `etanol.txt`, `metanol.txt` e `pentanol.txt`. Armazene eles no diret√≥rio `~/curso_senai/comandos_basicos/`.
* Para entrar nos arquivos √© s√≥ usar `nano nome_do_arquivo`
.orange[Input]
.code-bg-gray[
```
# Por exemplo
$ nano teste.txt
```
* Confira que conte√∫do do diret√≥rio.
] ] ]

---
## `mv` - *Move*
.panelset[ .panel[.panel-name[`mv`]
O comando `mv` serve para mover arquivos de uma pasta a outra. Al√©m este comando
tamb√©m pode ser usado para mudar os nomes dos elementos. A sintaxe para mover
arquivos √®:
.orange[Input]
.code-bg-gray[
```
$ mv arquivo.txt diretorio/
```
] ]
.panel[.panel-name[Pr√°tica 1]
.blue[**Agora √© sua vez...**]
* Dentro da pasta `~/curso_senai/comandos_basicos`, crie um novo diret√≥rio que se chame `01.Exercicio`.
* Transfira o arquivo que criou com `nano` chamado `teste.txt` que est√° armazenado na pasta `~/curso_senai/comandos_basicos` para o diret√≥rio que acabou de criar.
* Que comando pode ser usado para confirmar as mudan√ßas feitas?
.orange[Input]
.code-bg-gray[.can-edit[
```
$
```
] ] ]
.panel[.panel-name[Trocando o nome]
O `mv` tamb√©m serve para trocar os nomes dos arquivos ou pastas. A sintaxe para
esta fun√ß√£o √©:
.orange[Input]
.code-bg-gray[
```
$ mv arquivo.txt novo_nome.txt
```
] ]
.panel[.panel-name[Pr√°tica 2]
.blue[**Agora √© sua vez...**]
* Agora use o comando `mv` para trocar o nome do arquivo `teste.txt` para `arquivo.txt`
* Que comando pode ser usado para confirmar as mudan√ßas feitas?
.orange[Input]
.code-bg-gray[.can-edit[
```
$
```
] ] ] ]
---
class: inverse
## Quiz
Depois de executar os seguintes comandos, Jo√£o colocou os arquivos `genes.txt` e
`proteinas.txt` no diret√≥rio errado. Os arquivos deveriam estar no diret√≥rio
`dados`.
.yellow[BASH]
.code-bg-gray[
```
$ ls -F
analises/ dados/
$ ls -F analises
bacterias.txt genes.txt genomas.txt proteinas.txt
$ cd analises
```
]
Preencha os espa√ßos para mover os arquivos para o diret√≥rio `dados/`
.yellow[BASH]
.code-bg-gray[.can-edit[
```
$ mv genes.txt proteinas.txt ___/___
```
] ]
---
## `cp` - *Copy*
.panelset[ .panel[.panel-name[`cp`]
O comando `cp` √© similar ao `mv`, por√©m ele c√≥pia o arquivo ao inv√©s de
transferir ele. Ou seja, ficar√° uma vers√£o do arquivo na pasta original.
A sintaxe deste comando √© muito simples: .orange[Input]
.code-bg-gray[
```
$ cp diretorio_de_origem/arquivo.txt diretorio_de_destino/
```
] ]
.panel[.panel-name[Pr√°tica]
.blue[**Agora √© sua vez...**]
* Use os comandos necess√°rios para saber onde voc√™ est√° neste momento. Se voc√™ n√£o estiver na pasta `~/curso_senai/comandos_basicos/`, vai at√© ela.
* Execute os comandos desde `~/curso_senai/comandos_basicos/`
* Copie o arquivo chamado `arquivo.txt` que est√° armazenado no diret√≥rio `~/curso_senai/comandos_basicos/01.Exercicio/` na pasta `~/curso_senai/comandos_basicos/`.
* Copie novamente `arquivo.txt` porem agora na pasta `~/curso_senai/`.
* Confira as mudan√ß√£s feitas
.orange[Input]
.code-bg-gray[.can-edit[
```
$
```
] ] ]
.panel[.panel-name[E diret√≥rios?]
Para c√≥piar arquivos √© s√≥ usar a op√ß√£o ou param√™tro `-r`.
Lembrando que todos os comandos tem um men√∫ de ajuda ao qual podem acessar com a
op√ß√£o `-h` ou `--help`.
] ]
---
class: inverse
## Quiz
Suponha que voc√™ criou um arquivo de texto plano, no seu diret√≥rio atual que
contem uma lista de testes estat√≠sticos que voc√™ precisa para analisar seus
dados e o chama de `estatsticos.txt`
Depois criar e salvar este arquivo, voc√™ percebeu que errou na escrita no nome,
e voc√™ quer corrigir o erro. Qual dos seguinte comando poderia ser usado para
isso?
1. `cp estatsticos.txt estatisticos.txt` 
2. `mv estatsticos.txt
estatisticos.txt` 
3. `mv estatsticos.txt .` 
4. `cp estatsticos.txt .`
---
## `rm` - *Remove*
.panelset[ .panel[.panel-name[`rm`]
Com o comando `rm` voc√™ pode remover arquivos e ou pastas. A sintaxe √©:
.orange[Input] .code-bg-gray[
```
$ rm arquivo.txt
```
]
üëÄÔ∏è**Neste tipo de sistemas n√£o existe a lixeira, por tanto o que for deletado,
n√£o poder√° ser recuperado, CUIDADO!**
] .panel[.panel-name[Pr√°tica]
.blue[**Agora √© sua vez...**]
* Ainda desde o diret√≥rio `~/curso_senai/comandos_basicos/`:
* Delete o arquivo chamado `arquivo.txt` do diret√≥rio `~/curso_senai/`
* Delete a c√≥pia que est√° na pasta `~/curso_senai/comandos_basicos/`
* Confira, s√≥ deve ter esse arquivo (`arquivo.txt`) dentro da pasta `~/curso_senai/comandos_basicos/01.Exercicio/`
.orange[Input]
.code-bg-gray[.can-edit[
```
$
```
] ]
]
.panel[.panel-name[Dica!]
Para usar o uso do comando `rm` mais seguro, sempre use a op√ß√£o `-i`. Esse
param√™tro faz com que o comando pe√ßa para o usu√°rio que confirme se quer mesmo
deletar o arquivou e/ou diret√≥rio.
Fa√ßa o teste:
* Crie um arquivo plano, no diret√≥rio atual.
* Delete ele usando a op√ß√£o `-i`
* O que aconteceu?
] ]

---
## Caracteres Curingas
.panelset[ .panel[.panel-name[Aster√≠stico]
O caracter `*` √© muito √∫til na linha de comando, pois ele representa zero ou
mais caracteres.
Por exemplo, no diret√≥rio `~/curso_senai/comandos_basicos/` temos os arquivos
`propanol.txt`, `etanol.txt` e `metanol.txt` e `pentanol.txt`., os quais
poderiam ser representados assim: `*.txt` (*tudo o que termina em `.txt`*).
Assim mesmo, os arquivos `propanol.txt` e `pentanol.txt` podem ser representados
como: `p*.txt` (*tudo o que come√ßa com `p` e termina com `.txt`).
]
.panel[.panel-name[Interregoca√ß√£o]
O caracter `?` tamb√©m √© um caracter curinga, mas ele s√≥ pode representar um
√∫nico caracter. Por exemplo, `?etanol.txt` (*um caracter seguido de
`etanol.txt`*) representaria metanol enquanto `*etanol.txt` (*tudo o que termina
em `etanol.txt`*) representaria `etanol.txt` e `metanol.txt`.
Podem ser usados v√°rios ao mesmo tempo. Por exemplo `????anol.txt`, o que indica
quatro caracteres seguidos de `anol.txt`, ou seja, `propanol.txt` e
`pentanol.txt`.
]
.panel[.panel-name[Pr√°tica]
Ok, mas na pr√°tica para que servem os caracteres curingas?
.blue[**Agora √© sua vez...**]
* Liste o conte√∫do do diret√≥rio `~/curso_senai/comandos_basicos/`
* Crie uma nova pasta chamada `02.Exercicio`
* Utilize os caracteres curingas para mover todos os arquivos que come√ßam com `p` para a pasta `~/curso_senai/comandos_basicos/02.Exercicio`
* Utilize os caracteres curingas para copiar todos os arquivos que tem a s√≠laba `ta`, sem importar com o que termina e come√ßa, para a pasta `~/curso_senai/comandos_basicos/02.Exercicio`
.orange[Input]
.code-bg-gray[.can-edit[
```
$
```
] ] ] ]
---
class: inverse
## Quiz
Quando executa dentro do diret√≥rio
`~/curso_senai/comandos_basicos/02.Exercicio`, qual dos comandos `ls` poderia produzir o seguinte *output*?

.green[Output] .code-bg-gray[
```
ethanol.txt metanol.txt
```
]

1. `ls *t*nol.txt` 
2. `ls *ta?ol.*` 
3. `ls *et?nol.txt` 
4. `ls etanol.*`

---
class: inverse
## Quiz
Suponha que voc√™ est√° iniciando um novo experimento e quer duplicar a estrutura
do diret√≥rio de experimentos previos para adicionar os novos dados.
Asuma que seu experimento previo esta em uma pasta chamada `18-09-2023`, que
contem a pasta `dados`, dentro da qual tem as pastas `brutos` e `processados`. O
objetivo √© copiar a estrutura do diret√≥rio `18-09-2023` no diret√≥rio
`20-10-2023` para obter uma estrutura similar a esta:
```{r, echo=FALSE, fig.align = 'center', out.width = "45%"}
knitr::include_graphics("03.Images/tree.png")
```
* Qual dos seguintes conjuntos de comandos poderiam atingir o objetivo?

---
class: inverse
## Quiz
```{r, echo=FALSE, fig.align = 'center', out.width = "45%"}
knitr::include_graphics("03.Images/tree.png")
```
```
$ mkdir 20-10-2023
$ mkdir 20-10-2023/dados
$ mkdir 20-10-2023/dados/processados
$ mkdir 20-10-2023/dados/brutos
```
```
$ mkdir 20-10-2023
$ cd 20-10-2023
$ mkdir dados
$ cd dados
$ mkdir brutos processados
```
---
class: inverse
## Quiz
```{r, echo=FALSE, fig.align = 'center', out.width = "45%"}
knitr::include_graphics("03.Images/tree.png")
```
```
$ mkdir 20-10-2023/dados/brutos
$ mkdir 20-10-2023/dados/processados
```
```
$ mkdir -p 20-10-2023/dados/brutos
$ mkdir -p 20-10-2023/dados/processados
```
```
$ mkdir 20-10-2023
$ cd 20-10-2023
$ mkdir dados
$ mkdir brutos processados
```
---
## Ainda temos muitos comandos para aprender
Para os seguintes comandos, crie uma pasta chamada `03.Exercicio`, dentro dela,
coloque os arquivos de texto, chamados `bssA_1.txt` e `bssA_2.txt`. Cada um
deles cont√©m uma uma sequ√™ncia do gene *bssA* que codifica para a enzima
*Benzylsuccinate synthase*.
* [Sequencia](https://www.ncbi.nlm.nih.gov/nuccore/MW762608.1?report=fasta) do arquivo `bssA_1.txt`
* [Sequencia](https://www.ncbi.nlm.nih.gov/nuccore/FJ810633.1?report=fasta) do arquivo `bssA_2.txt`
.orange[Input]
.code-bg-gray[.can-edit[
```
$
```
] ]
---
## Comandos para visualizua√ß√£o de arquivos
.panelset[ .panel[.panel-name[`less`] Este comando permite ler o conte√∫do de um
arquivo de texto que cabe no tamanho da janela. N√£o l√™ todo o arquivo.
.orange[Input]
.code-bg-gray[.can-edit[
```
$ less bssA_1.txt
```
] ]
Para sair presione `q`
]
.panel[.panel-name[`more`]
Este comando permite ler o conte√∫do de um arquivo de texto uma p√°gina (uma tela)
por vez. `more` pode ler todo o arquivo. Presionando a tecla Enter, ele vai
passando linha por linha at√© o fim do arquivo.
.orange[Input]
.code-bg-gray[.can-edit[
```
$ less bssA_1.txt
```
] ]
Para sair presione `q`. ]
.panel[.panel-name[`head`]
Permite ler as primeiras 10 linhas do arquivo.
.orange[Input]
.code-bg-gray[.can-edit[
```
$ head bssA_2.txt
```
] ]
Se quiser aumentar ou diminuir o n√∫mero de linhas, coloque o n√∫mero de linhas
que deseja como um param√™tro
.orange[Input]
.code-bg-gray[.can-edit[
```
$ head -n 12 bssA_2.txt
```
] ] ]
.panel[.panel-name[`tail`]
Permite ler as √∫ltimas 10 linhas do arquivo.
.orange[Input]
.code-bg-gray[.can-edit[
```
$ tail bssA_2.txt
```
] ]
Ao igual que com o comando anterior, pode modificar o n√∫mero de linhas que
quiser ler.
.orange[Input]
.code-bg-gray[.can-edit[
```
$ tail -n 8 bssA_2.txt
```
] ] ]
.panel[.panel-name[`cat`]
Imprime o conte√∫do do arquivo que cabe na tela.
.orange[Input]
.code-bg-gray[.can-edit[
```
$ cat bssA_1.txt
```
] ]
Uma das op√ß√µes (`-n`) deste comando, permite que as linhas sejam numeradas
.orange[Input]
.code-bg-gray[.can-edit[
```
$ cat -n bssA_2.txt
```
] ] ] ]
---
## Comandos para manipula√ß√£o de arquivos
.panelset[ .panel[.panel-name[`wc`]
`wc` - *Word Count*, permite contar as linhas, palavras e caracteres de um
arquivo.
.orange[Input]
.code-bg-gray[.can-edit[
```
$ wc bssA_2.txt
```
] ]
.green[Output] .code-bg-gray[
```
12      21     842 bssA_2.txt
```
]
* Se voc√™ quisesse obter essa informa√ß√£o para os dois arquivos ao mesmo tempo, que linha de comando usaria?
.code-bg-gray[.can-edit[
```
$
```
] ]
* A op√ß√µes `-l`, `-m` e `-w` mostram s√≥ o n√∫mero de linhas, caracteres ou palavras, respetivamente.
]
.panel[.panel-name[`cat`]
O comando `cat` - *Concatenate*, al√©m de ser usado para visualizar arquivos,
tamb√©m √© usado para manipular arquivos, especificamente para concatena√ß√£o
(juntar) de arquivos.
.orange[Input] .code-bg-gray[.can-edit[
```
$ cat bssA_1.txt bssA_2.txt > bssA_all.txt
```
]]
O caracter `>`, diz paro sistema redirecionar a sa√≠da do comando para um
arquivo, ao inv√™s de printar na tela. **CUIDADO**: Se o arquivo n√£o existe, o
sistema criar√° o arquivo, por√©m se o arquivo j√° existe, ele ser√° sobrescrito
silenciosamente, o que levar√° a uma perda de dados.
* Use os comandos de visualiza√ß√£o para dar uma olhada no novo arquivo criado (`bssA_all.txt`)
]
.panel[.panel-name[`grep`]
O comando `grep` permite procurar padr√µes dentro de um arquivo. Dado um ou
v√°rios caracteres para ele procurar, ele imprimir√° na tela a linha completa onde
o padr√£o foi encontrado.
.orange[Input] .code-bg-gray[.can-edit[
```
$ grep 'CGACT' bssA_all.txt
```
]]
.green[Output] .code-bg-gray[
```
CAGGACGACTGCAACGAATTAACAGATGTGATTCTTGATGCAGCCTACAGCCTGCGGACACAAGAGCACT
TCCGAGGGCGGCGGTTCGATCTTCCCGGCGAAGCTGCTGGAAATCACCCTCAACGACGGCTACGACTGGT
ATGGCCAATTGGGAAGGCTACGAGGAAATGCGACTGGAGTTCAAGCGCGCGCCG
```
]
* A op√ß√£o `-c`, diz para `grep` contar o n√∫mero de linhas em que o padr√£o aparece. Sendo muito √∫til por exemplo para contar sequ√™ncias.
]
.panel[.panel-name[`find`]
Procura arquivos
.orange[Input] .code-bg-gray[.can-edit[
```
$ find . -name '*.txt'
```
]]
.green[Output] .code-bg-gray[
 * O que significa `.` no c√≥digo?
 * O que significa `*.txt`
]
* E se voc√™ quiser procurar por arquivos que come√ßam com p, em todo seu diret√≥rio `home`. Qual seria a linha de comando?
.orange[Input] .code-bg-gray[.can-edit[
```
$
```
] ] ]
.panel[.panel-name[`gzip`]
Compacta√ß√£o de arquivos
.orange[Input] .code-bg-gray[.can-edit[
```
$ gzip *
```
]]
Assim, ser√£o compactados todos os arquivos dentro do diret√≥rio atual. Use `ls`
para ver a nova extens√£o dos arquivos.
Para descompactar o comando √©:
.orange[Input] .code-bg-gray[.can-edit[
```
$ gzip -d bssA_all.txt
```
]]
]
.panel[.panel-name[`tar`]
Compacta√ß√£o de arquivos
.yellow[BASH] .code-bg-gray[.can-edit[
```
$ tar -cvf arquivo.tar meudiretorio/
```
]]
Compacta o diret√≥rio `meudiretorio/` e o nome do arquivo ser√° `arquivo.tar`
Para descompactar o comando √©:
.yellow[BASH] .code-bg-gray[.can-edit[
```
$ tar -xvf arquivo.tar
```
]]
]
.panel[.panel-name[`zip`]
Compacta√ß√£o de arquivos
.yellow[BASH] .code-bg-gray[.can-edit[
```
$ zip -r meudiretorio.zip meudiretorio/
```
]]
Compacta o diret√≥rio `meudiretorio/` em um arquivo chamado `meudiretorio.zip`
Para descompactar o comando √©:
.yellow[BASH] .code-bg-gray[.can-edit[
```
$ unzip meudiretorio.zip
```
]]
] ]
---
## Capturando o *output* dos comandos
Ao igual que a gente viu com a saida do comando `cat`, isso pode ser feito para tudo o que gera um *output* que √© normalmente mostrado na tela.
Por exemplo: (dentro da pastas `~/curso_senai/comandos_basicos/exercicios/`)
.orange[Input] .code-bg-gray[.can-edit[
```
$ wc -l bss* > linhas.txt
```
]]
No arquivo `linhas.txt` ficou salvo a sa√≠da desse comando, ou seja do n√∫mero de
linhas de todos os arquivos que come√ßam com `bss` dentro de
`~/curso_senai/comandos_basicos/03.Exercicio/`, e o total.
.orange[Input] .code-bg-gray[.can-edit[
```
$ cat linhas.txt
```
]]
---
## Caturando o *output* dos comandos
O comando `sort` permite ordenar arquivos. Por *default* a ordena√ß√£o √©
alphanumerica. Se quisermos organizar s√≥ de maneira numerica, basta usar a `-n`.
.orange[Input] .cod-bg-gray[.can-edit[
```
$ sort -n linhas.txt
```
]]
.green[Output] .code-bg-gray[
```
 12 bssA_2.txt
 27 bssA_1.txt
 39 bssA_all.txt
 78 total
```
]
Assim mesmo poderiamos salvar o arquivo ordenado em um novo arquivo
.orange[Input] .code-bg-gray[.can-edit[
```
$ sort -n linhas.txt > linhas_ordenado.txt
```
]]
* Use os comandos de visualiza√ß√£o para dar uma olhada no arquivo `linhas_ordenado.txt`

---
## Capturando o *output* dos comandos
Al√©m do operador `>`, tamb√©m temos um operado similar `>>`, o qual funciona um
pouco diferente que o primeiro. Vamos usar o comando `echo` para aprender a
diferen√ßa entre os dois. O `echo` nos permite imprimer texto na tela.
.orange[Input] .code-bg-gray[.can-edit[
```
$ echo O comando echo printa texto na tela
```
]]
.green[Output] .code-bg-gray[
```
O comando echo printa texto na tela
```
]
Agora vamos ver a diferen√ßa entre os dois operadores: .orange[Input]
.code-bg-gray[.can-edit[
```
$ echo ol√° > arquivo1.txt
```
] ]
.orange[Input] .code-bg-gray[.can-edit[
```
$ echo ol√° >> arquivo2.txt
```
]]
Execute duas vezes os √∫ltimos dois comandos e depois d√™ uma olhada nos arquivos.
Qual √© a diferen√ßa?
---
class: inverse
### Quiz
.blue[**Agora √© sua vez...**]
* Crie um novo diret√≥rio dentro de `~/curso_senai/comandos_basicos/`, chamado `04.Exercicio`
* Descarregue o arquivo `bacterias.csv` e armazene ele no diret√≥rio que acabou de criar. A extens√£o `.csv`, √© outro tipo de arquivo de texto plano, se refere normalmente a informa√ß√µes organizadas em colunas separadas por v√≠rgulas (*comma separated values*)
* Explore o arquivo, sem modific√°-lo.
* Depois dos seguintes comandos, o que ter√° no arquivo `bacterias_sub.csv`:
.orange[Input] .code-bg-gray[.can-edit[
```
$ head -n 3 bacterias.csv  > bacterias_sub.csv
$ tail -n 2 bacterias.csv >> bacterias_sub.csv
```
]]
1. As primeiras tr√™s linhas de `bacterias.csv` 
2. As duas √∫ltimas linhas de
`bacterias.csv` 
3. As primeiras tr√™s e as √∫ltimas duas linhas de `bacterias.csv`
4. A segunda e a terceira linha de `bacterias.css`
---
## Combinando m√∫ltiplos comandos
Nada nos impede encadear comandos consecutivamente. Por exemplo, enviar a sa√≠da
de `wc` diretamente para `sort`, e em seguida enviar a sa√≠da para `head`. Esto
tira a necessidade de arquivos intermediarios. Para encadear comandos se usa o
operador `|`, chamado *pipe*.
.orange[Input] .code-bg-gray[.can-edit[
```
$ wc -l bssA* | sort -n
```
]]
.green[Output] .code-bg-gray[
```
      12 bssA_2.txt
      27 bssA_1.txt
      39 bssA_all.txt
      78 total
```
]
---
## Combinando m√∫ltiplos comandos
Podemos enviar esse output usando outro `|` a `head`
.orange[Input] .code-bg-gray[.can-edit[
```
$ wc -l bssA* | sort -n | head -n 1
```
]]
.green[Output] .code-bg-gray[
```
      12 bssA_2.txt
```
]
---
class: inverse
## Quiz
Suponha que voc√™ que encontrar os tr√™s arquivos com menor n√∫mero de linhas. Qual
comando seria o correcto?
1. `wc -l * > sort -n > head -n 3` 
2. `wc -l * | sort -n | head -n 1-3` 
3. `wc -l * | head -n 3 | sort -n` 
4. `wc -l * | sort -n | head -n 3`
---
## Mais comandos √∫teis de Linux
```
wget # Permite descarreguar arquivos da web (p.e. bases de dados)
df    # Mostra o espa√ßo em disco
free -g     # info da mem√≥ria
uname -a    # Mostra a informa√ß√£o da m√°quina
du -sh    # mostra o espa√ßo usado em disco
du sh *     # mostra o espa√ßo usado em disco por arquivos e/ou diret√≥rios
du -s * | sort -nr    # Mostra o espa√ßo usado em disco por arquivos e/ou dir√©torios ordenados por tamanho
top     # Mostra o top de consumidores de memoria e CPU
who     # Mostra quem est√° logado no sistema
ps    # Mostra os processos rodando pelo usu√°rio
ps -e     # Mostra todos os processos rodando no sistema
ps -o %t -p <pid>     # Mostra quanto tempo leva rodando um determinado proceso (pid)
kill <pid>    # Mata o processo
```
---
class: inverse, center, middle
# *Loops*
## Aumenta a complexidade por√©m tamb√©m o poder
---
## *Loops*
Os *loops* ou la√ßos s√£o uma constru√ß√£o de programa√ß√£o que nos permite repetir um
ou v√°rios comandos para cada item de uma lista. Eles s√£o fundamentais para
melhorias de produtividade atrav√©s de automa√ß√£o.
Semelhante aos caracteres curingas e ao uso do tab para autocompletar palavras,
o uso de *loops* tamb√©m reduz a quantidade de digita√ß√£o necess√°ria, reduzindo
tamb√©m o n√∫mero de erros de digita√ß√£o.
---
## *Loops*
Imagine que tem centenas de arquivos com genomas de bacterias chamados `bacteria_a`, `bacteria_b` e `bacteria_c` (descarregue os arquivos). Para o exemplo s√≥ teremos esses tr√™s arquivos, mas os principios podem ser aplicados amuitos mais arquivos ao mesmo tempo.

A estrutura destes arquivos √© a mesma, o nome abreviado, a classifica√ß√£o taxon√¥mica e a data de atualiza√ß√£o, est√£o nas primeiras tr√™s linhas, seguido de sequ√™ncias de DNA en las demais linhas. D√™ uma olhada nos arquivos. Mas antes, crie uma pasta chamada `05.Exercicio`, dentro do diret√≥rio `~/curso_senai/comandos_basicos/`. 

Coloque os arquivos dentro da nova pasta criada.

.orange[Output] .code-bg-gray[.can-edit[
```
$ head -n 5 bacteria_*
```
]]
---
## *Loops*
Gostariamos de imprimir a classifica√ß√£o de cada esp√©cie (segunda linha). Para cada arquivo precisariamos executar o comando `head -n 2` e enviar a sa√≠da direto para `tail -n 1`. Usaremos um *loop* para resolver esse problema.

Mas antes, essa √© a estrutura gen√©rica de um *loop* em forma de pseudoc√≥digo:

.code-bg-gray[
```
for i in lista_de_elementos
# A palavra 'for' indica o inicio de um for-loop
do
# A palavra 'do' indica o inicio da lista de comandos a ser executada
  comando $i
  # A indenta√ß√£o n√£o √© obrigat√≥ria, por√©m melhora a compreens√£o
done
# A palavra `done` indica o fim do loop
```
]
---
## *Loops*
No nosso exemplo, ficaria assim: 

.orange[Input] .code-bg-gray[.can-edit[
```
$ for arquivo in bacteria_a bacteria_b bacteria_c
> do
>   echo $arquivo
>   head -n 2 $arquivo | tail -n 1
> done
```
]]
.green[Output] .code-bg-gray[.can-edit[
```
bacteria_a
CLASSIFICA√á√ÉO: Pseudomonas putida
bacteria_b
CLASSIFICA√á√ÉO: Escherichia coli
bacteria_c
CLASSIFICA√á√ÉO: Bacillus subtilis
```
]]
---
## *Loops*
### Algumas explica√ß√µes
* O prompt muda de `$` a `>` para nos lembrar que n√£o temos completado o comando ainda. Volta ao normal quando o comando est√° terminado.
* Quando o sistema ve a palavra `for`, entende que deve repetir um o v√°rios comandos para cada um dos elementos em uma lista. Cada vez que o *loop* √© executado (chamado de itera√ß√£o), um item da lista √© atribu√≠do √† vari√°vel, e os comandos dentro do *loop* s√£o executados, antes de passar para o pr√≥ximo item da lista.
* Dentro do *loop* chamamos o valor da vari√°vel usando o `$`, para o sistema entender como uma vari√°vel e n√£o como texto.

---
## *Loops*
**No nosso exemplo**

A nossa lista cont√©m tr√™s arquivos: `bacteria_a`, `bacteria_b`, `bacteria_c`.
Cada vez que o *loop* itera: 
1. Usamos `echo` para imprimir o valor atribuido √† vari√°vel `$arquivo` nessa itera√ß√£o. Isto n√£o √© obrigat√≥rio, mas √© uma boa pr√°tica para ter mais facilidade para acompanhar os resultados. 
2. √â executado o comando `head` no elemento que est√° sendo iterado (valor de `$arquivo`), extra√≠ndo as duas primeiras linhas do arquivo (*output*) 
3. O *output* do comando `head` √© enviado diretamente pro comando `tail` que ent√£o imprime a segunda linha. Termina a primeira itera√ß√£o. 
4. O processo come√ßa de novo, com o seguinte item da lista, e assim vai at√© iterar em todos os elementos da lista.

* Lembrando o nome da vari√°vel pode ser o que a gente quiser, mas sempre √© uma boa pr√°tica colocar um nome que indique ao que esta-se referindo. Outro bom nome para a vari√°vel no exemplo anterior poderia ser `$genoma`

---
class: inverse
## Quiz
* Tente escrever um *loop*, que use o comando `echo` para imprimir na tela os n√∫meros de 0 a 9?

.orange[Input] 
.code-bg-gray[.can-edit[
```
$
```
]]
---
class: inverse
## Quiz
* No direct√≥rio `~/curso_senai/comandos_basicos/02.Exercicio/` o comando `ls *.txt`

.green[Output] 
.code-bg-gray[.can-edit[
```
etanol.txt	metanol.txt	pentanol.txt	propanol.txt
```
]]

* Qual seria o *output* do seguinte c√≥digo?
.code-bg-gray[.can-edit[
```
$ for alcool in *.txt
> do
>   ls *.txt
> done
```
]]
* E o resultado deste?
.code-bg-gray[.can-edit[
```
$ for alcool in *.txt
> do
>     ls $alcool
> done
```
]]
---
class: inverse
## Quiz
**Respostas**
.code-bg-gray[.can-edit[
```
etanol.txt	metanol.txt	pentanol.txt	propanol.txt
etanol.txt	metanol.txt	pentanol.txt	propanol.txt
etanol.txt	metanol.txt	pentanol.txt	propanol.txt
etanol.txt	metanol.txt	pentanol.txt	propanol.txt
etanol.txt	metanol.txt	pentanol.txt	propanol.txt
```
]]
* Em cada elemento que o *loop* itera, ele lista os elementos que terminam em `.txt`.

---
class: inverse
## Quiz
**Respostas**
.code-bg-gray[.can-edit[
```
etanol.txt
metanol.txt
pentanol.txt
propanol.txt
```
]]
*A cada itera√ß√£o o *loop* chama o elemento assignado na vari√°vel.
---
class: inverse
## Quiz
* Qual seria a sa√≠da para o seguinte *loop*
.code-bg-gray[
```
$ for alcool in e*
> do
>   ls $alcool
> done
```
]
1. N√£o √© listado nenhum arquivo 
2. Todos os arquivos s√£o listados 
3. `metanol.txt`, `etanol.txt` e `pentanol.txt` s√£o listados 
4. S√≥ `etanol.txt` ser√° listado
---
class: inverse
## Quiz
* E agora?

.code-bg-gray[
```
$ for alcool in *e*
> do
>   ls $alcool
> done
```
]
1. Os mesmos arquivos ser√£o listados 
2. Todos os arquivos s√£o listados desta vez
3. Nenhum arquivo ser√° listado 
4. Os arquivos `metanol.txt`, `etanol.txt`,
`pentanol.txt` ser√£o listados? 
5. S√≥ o arquivo `etanol.txt` ser√° listado
---
class: inverse
## Quiz
Ao igual que vimos antes, dentro de um *loop* tamb√©m o poss√≠vel salvar o
resultado dentro de um arquivo usando `>`.
* Qual seria o efeito do seguinte *loop*?
.code-bg-gray[
```
for alcool in *.txt
do
  echo $alcool
  cat $alcool > alcoois
done
```
]
1. Printa na tela `etanol.txt`, `metanol.txt`, `pentanol.txt` e `propanol.txt`,
e salva o conte√∫do de `propanol.txt` num arquivo chamado `alcoois` 
2. Printa na tela `etanol.txt` e `metanol.txt`, e o texto dos outros dos arquivos √© salvado dentro de `alcoois` 
3. Printa `etanol.txt`, `metanol.txt` e `pentanol.txt`, e o texto de `propanol.txt` √© salvo no arquivo `alcoois` 
4. Nenhuma das anteriores
---
class: inverse
## Quiz
* Qual seria o efeito do seguinte *loop*:
.code-bg-gray[
```
$ for alcool in *.txt
do
  cat $alcool >> todos
done
```
]
1. O texto de todos os arquivos terminados em `*.txt` sera concatenado e salvado no arquivo chamado `todos` 
2. O texto de `etanol.txt` ser√° salvado no arquivo `todos` 
3. O texto de todos os arquivos terminados em `*.txt` ser√£o printados na tela e salvos no arquivo `todos`
---
## *Loops*
### Agora mais complexo ainda
Continuando com o nosso exemplo dos genomas das bacterias no diret√≥rio `~/curso-senai/comandos_basicos/05.Exercicio/`. 
Vamos ver um *loop* um pouco mais complexo:

.orange[Input] 
.code-bg-gray[.can-edit[
```
$ for genoma in bacteria_*
> do
>   echo $genoma
>   head -n 100 $genoma | tail -n 20
done
```
]]
A cada itera√ß√£o √© printado na tela o genoma iterado, as primeiras 100 linhas s√£o enviadas diretamente para o `tail`, que extrai as √∫ltimas 20 linhas dessas 100 (linhas 81 - 100) e esse resultado √© printado na tela.
---
## *Loops*
Agora vamos supor que a gente quer modificar os arquivos, por√©m quer manter as vers√µes originais deles. Para isto vamos copiar os arquivos originais e vamos modificar os nomes para `original_bacteria_a`, `original_bacteria_b` e `original_bacteria_c`

.orange[Input] 
.code-bg-gray[.can-edit[
```
$ for $bacteria in bacteria_*
> do
>   cp $bacteria original_$bacteria
> done
```
]]
* Confira o resultado
* Que modifica√ß√£o faria ao comando para saber com que arquivo est√° trabalhando e/ou se o *loop* foi executado?

---

## *Loops*
### Graficamente
```{r, echo=FALSE, fig.align = 'center', out.width = "30%"}
knitr::include_graphics("03.Images/loop.png")
```
---
## `screen`
O `screen` √© uma aplica√ß√£o desenvolvida para linux, que tem como objetivo a multiplexa√ß√£o de terminais. Ou seja, ele divide o terminal f√≠sico em v√°rias sess√µes virtuais. Quando voc√™ est√° trabalhando conectado remotamente a um servidor, e usa o `screen`, voc√™ pode deixar os seus processos em execu√ß√£o e desligar seu computador, eles ficaram rodando em *background*.
---
## `screen`
Para iniciar uma sess√£o: .orange[Input] .code-bg-gray[.can-edit[
```
$ screen -S minhaSessao
```
] ]

Para sair da sess√£o mantenha apertada a tecla **Ctrl**, enseguida aperte a tecla **a**, seguido da tecla **d**. Para voltar na sess√£o .orange[Input] 
.code-bg-gray[.can-edit[
```
$ screen -ls #Lista as sess√µes ativas, caso n√£o lembre o nome
$ screen -r minhaSessao #entra na sess√£o desejada.
```
]]
---
## `scp` *Secure Copy Between Machines*
`scp` √© um comando que permite copiar elementos entre um servidor e seu computador e viceversa.
.code-bg-gray[.can-edit[
```
$ scp origem destino
```
]]
* Exemplo 1: Do servidor para seu computador
.code-bg-gray[.can-edit[
```
$ scp user@143.109.85.222:caminho/ao/arquivo.txt caminho/no/seu/pc
```
]]
* Exemplo 2: Do seu computador para o servidor
.code-bg-gray[.can-edit[
```
$ scp caminho/no/seu/pc/arquivo.txt user@143.109.85.222:caminho/onde/quer/copiar/no/servidor/
```
]]
Se voc√™ quiser copiar um diret√≥rio completo basta colocar a op√ß√£o `-r` ap√≥s o
`scp`
---
class: inverse, center, middle
# ANACONDA

---
## Anaconda

**Anaconda** √® uma distribui√ß√£o livre e aberta de v√°rias linguagens, entre elas *Python* e *R*, utilizada na ci√™ncia de dados e bioinform√°tica. As diferentes vers√µes dos programas se administram mediante um sistema de gest√£o chamado *conda*, o qual faz bastante simples instalar, executar e atualizar programas.

As instru√ß√µes de instala√ß√£o de conda est√£o [aqui](https://conda.io/projects/conda/en/latest/user-guide/install/index.html#regular-installation)

---
## Anaconda
* Ferrmentas de bioinform√°tica escritas em diferentes linguagens e/ou vers√µes.
* Sistema operacional com uma vers√£o s√≥
* Problema na instala√ß√£o de programas.
* Com Anaconda podem ser criados v√°rios ambientes virtuais com diferentes linguagens e vers√µes

---
## Anaconda
Alguns comando do `conda` s√£o:
.orange[BASH] .code-bg-gray[.can-edit[
```
$ conda create -n meuambiente # cria um ambiente chamado meuambiente
$ conda activate meuambiente # ativa o ambiente meuambiente
$ conda env list # lista todos os ambientes criados
$ conda list # executado dentro de um ambiente, lista as ferramentas instaladas nesse ambiente
```
]]
* Durante o processamento de gen√¥mica e metagen√¥mica em linha de comando usaremos conda.

---
class: inverse, center, middle
.huge[ # 3. Estrat√©gias de An√°lises Gen√¥micas - *Command Line Interface* (CLI) ]

---
## Protocolo de sequenciamento Illumina

--

1. Extra√ß√£o de DNA/RNA

--

2. Verifica√ß√£o da qualidade da extra√ß√£o: Pureza e quantidade

--

3. Prepara√ß√£o das bibliotecas: Fragmenta√ß√£o do DNA, liga√ß√£o dos adaptadores e opcionalmente dos *barcodes*.

--

4. Prepara√ß√£o dos cluster: liga√ß√£o dos fragmentos na *flowcell*, amplifica√ß√£o em ponte

--

5. Sequenciamento por s√≠ntese: nucleot√≠deos modificados (fluor√≥foro e bloqueador remov√≠vel), laser para a detec√ß√£o da base: .red[A] .green[T] .blue[C] .yellow[G]

--
6. *Basecalling*: Transformar o sinal de fluorescencia em nucleot√≠deos .red[A] .green[T] .blue[C] .yellow[G], escritos em um arquivo de texto plano. **O FAMOSO ARQUIVO FASTAQ**

--

... Processamento bioinform√°tico ...

---
## Workflows
```{r, echo=FALSE, fig.align = 'center', out.width = "80%"}
knitr::include_graphics("03.Images/workflow.png")
```
---
### Entendendo o arquivo `.fastq` ou `.fq`
```{r, echo=FALSE, fig.align = 'center', out.width = "80%"}
knitr::include_graphics("03.Images/fastq.png")
```
* Em sequenciamentos *paired-end*, s√£o dois arquivos, um com as *reads* *forward* e outro com as *reads reverse*.

---
## Lembrando o que significa *paired-end*
```{r, echo=FALSE, fig.align = 'center', out.width = "80%"}
knitr::include_graphics("03.Images/se_pe.png")
```
---
### Entendendo o arquivo `.fastq` ou `.fq`
```{r, echo=FALSE, fig.align = 'center', out.width = "60%"}
knitr::include_graphics("03.Images/fastq2.png")
```

--
* Cabe√ßalho
  * Cada sequ√™ncia come√ßa com *@*
  * Informa√ß√£o da m√°quina de sequenciamento (ID)
  * Informa√ß√£o da *flowcell* (ID, coordenadas, bloco)
  * N√∫mero do par
  * Sequencia dos adaptadores
  
--

* Sequ√™ncia
  * Tamanho em Illumina de at√© 300 bp
  
--

* S√≠mbolo *+*
  * Nem sempre est√°. A fun√ß√£o √© separador de informa√ß√µes
  
--

* Qualidade

---
### Phred Quality Score

* A qualidade das sequ√™ncias est√° determinada por la nota o *score Phred (q)*

Segundo a seguinte equa√ß√£o:

$$q = -10 * log_{10}(P)$$ 

Onde, 

$q$ √© a nota *Phred*

e $P$ √© a probabilidade que a base esteja errada.

Assim ent√£o:

* $q = 10$ √© 1 base errada a cada 10 (90%); $p = 0.1$

* $q = 20$ √© 1 base errada a cada 100 (99%); $p = 0.01$

* $q = 30$ √© 1 base errada a cada 1000 (99.9%); $p = 0.001$

--

**M√≠nimo aceit√°vel √©** $q > 20$, o **ideal** √© $q > 30$

---
### Phred Quality Score
Para facilitar a escrita e leitura da informa√ß√£o de qualidade, √© usada a table
*ASCII*, para transformar os dois d√≠gitos da nota *Phred* em um √∫nico car√°ter,
para bater com cada base da sequ√™ncia.
[ASCII table](https://www.asciitable.com/)

---
## Como avaliar a qualidade das sequ√™ncias
`FASTQC` √© uma ferramenta que permite visualizar a informa√ß√£o de qualidade das
sequ√™ncias de uma manera gr√°fica e interativa.

---
## Trimmagem (Filtragem)
√â o processo de remo√ß√£o de `reads` com baixa qualidade. √â poss√≠vel filtrar
sequ√™ncias baseado no el *score Phred*, remo√ß√£o de adaptadores, remo√ß√£o de bases
ao √≠nicio ou final das sequ√™ncias. Tamb√©m √© poss√≠vel trimar por tamanho, por
exemplo eliminar todas as `reads` menores de 50 bp.
Alguns programas:
* Trimmomatic
* Trimgalore
* Fastx tool kit

---
class: inverse, middle, center
## Tempo de colocar em pr√°tica!
.center[ ![](https://media.giphy.com/media/MdA16VIoXKKxNE8Stk/giphy.gif) ]

---
### Pr√°tica I
**Conte√∫do**
* Que √© conda?
* Instala√ß√£o de programas
* Importa√ß√£o de sequ√™ncias
* An√°lises de qualidade das sequ√™ncias
* Trimmagem

---
## Workflow
### Avalia√ß√£o da qualidade com `fastqc`
```{r, echo=FALSE, fig.align = 'center', out.width = "70%"}
knitr::include_graphics("03.Images/workflow2.png")
```
---
### Por que √© necess√°rio revisar a qualidade das sequ√™ncias?
Todas etapas do sequenciamento s√£o sucept√≠veis de ter erros:

--

* Amplifica√ß√£o por PCR

--

* Adi√ß√£o das bases pela polimerase

--

* *Base-calling*

--

* Taxa de erro da Illumina ~0.1%**

--

[**Pr√°tica**](https://github.com/khidalgo85/CURSO_SENAI/tree/master#0-organiza%C3%A7%C3%A3o-dos-dados)

---
class: center, middle, inverse

# Montagem de Genomas

---

.center[## Montagem de Genomas *de Novo*]
.center[##Sem refer√™ncia)]

```{r, echo=FALSE, fig.align = 'center', out.width = "70%"}
knitr::include_graphics("03.Images/montagem.png")
```

* Como √© poss√≠vel re-armar o jornal a partir dos fragmentos?

---
## Mas antes de "montar" o genoma
### Uma considera√ß√£o importante √© a **Cobertura**

A cobertura √© quantas vezes em m√©dia cada base do genoma foi sequenciada. Pode ser calculado pela seguinte equa√ß√£o:

$$C = (L*N)/G$$

Onde:
$L$ √© o tamanho das *reads*,
$N$ √© igual ao n√∫mero de leituras e
$G$ √© igual ao tamanho aproximado do genoma

**Exemplo**
Foi sequenciado o genoma de uma bact√©ria com tamanho aproximado de 2 Mbp. Se obtiveram 3 milh√µes de *reads* paired end de 100 bp. O c√°lculo da cobertura para esse genoma √©:

$$C = ((100*2)*3.000.000)/2.000.000$$
$$C = 300x$$

Entre maior seja a cobertura a qualidade da montagem tamb√©m ser√° maior. Para Illumina $100$, PacBio $50x$

> **Desafio**
> Considerando que o nosso genoma exemplo tem um tamanho de genoma aproximado de 4.8 Mbp. Qual seria a cobertura do sequenciamento?

---

### Mas, e que √© o que significa "montar" um genoma

A partir dos fragmentos (pedacinhos) armar o genoma (p√°gina do jornal). Por√©m sem molde, como sabemos qual √© a ordem das pe√ßas? 

.center[
![](https://media.giphy.com/media/XbxxZbRzpcuSn1rbYk/giphy.gif)
]

---

## A montagem se organiza em:

* Contigs:  Sequ√™ncias contiguas, formadas pela sobreposi√ß√£o de um conjunto de *reads*

```{r, echo=FALSE, fig.align = 'center', out.width = "70%"}
knitr::include_graphics("03.Images/contigs.png")
```

* Scaffolds: Uni√£o de contigs

```{r, echo=FALSE, fig.align = 'center', out.width = "70%"}
knitr::include_graphics("03.Images/scafold.png")
```

---

## Algor√≠tmos

Existem diferentes algor√≠tmos para montar genomas, e devem ser usados segundo o tipo de sequ√™ncias (curtas ou longas).

.center[
![](https://media.giphy.com/media/3o7527pa7qs9kCG78A/giphy.gif)
]

---
## O que √© um algor√≠tmo?

Sequ√™ncia de instru√ß√µes ou comandos realizados de forma sistem√°tica com a finalidade de resolver um problema ou executar uma determinada tarefa. Ou √© um conjunto espec√≠fico de instru√ß√µes l√≥gicas para executar uma tarefa ou resolver um problema.

**Exemplo: Algor√≠tmo "Dia a dia pro trabalho"**
1. Acordar
2. Tomar banho
3. Vestir-se
4. Tomar caf√©
5. Tirar o carro da garagem
6. Dirigir at√© o trabalho

---
## O que √© um algor√≠tmo?

Sequ√™ncia de instru√ß√µes ou comandos realizados de forma sistem√°tica com a finalidade de resolver um problema ou executar uma determinada tarefa. Ou √© um conjunto espec√≠fico de instru√ß√µes l√≥gicas para executar uma tarefa ou resolver um problema.

```{r, echo=FALSE, fig.align = 'center', out.width = "30%"}
knitr::include_graphics("03.Images/tarefa-algoritmo.png")
```

---
## Algor√≠tmos

Existem diferentes algor√≠tmos para montar genomas, e devem ser usados segundo o tipo de sequ√™ncias (curtas ou longas).


* Overlap - Layout - Consensus
  * PacBio
  
```{r, echo=FALSE, fig.align = 'center', out.width = "70%"}
knitr::include_graphics("03.Images/olc.png")
```
---
## Algor√≠tmos
* Grafo de De Bruijn
  * Illumina

```{r, echo=FALSE, fig.align = 'center', out.width = "70%"}
knitr::include_graphics("03.Images/debruijn.png")
```
---
## *Short reads* vs *Long reads*

```{r, echo=FALSE, fig.align = 'center', out.width = "70%"}
knitr::include_graphics("03.Images/colibri.png")
```
---
## As repeti√ß√µes s√£o um grande problema!

```{r, echo=FALSE, fig.align = 'center', out.width = "70%"}
knitr::include_graphics("03.Images/avion.png")
```
---
### *Short reads*

```{r, echo=FALSE, fig.align = 'center', out.width = "70%"}
knitr::include_graphics("03.Images/avion2.png")
```
---
### *Long reads*

```{r, echo=FALSE, fig.align = 'center', out.width = "70%"}
knitr::include_graphics("03.Images/avion3.png")
```

---
## Resumindo...

1. Entre menores sejam as pe√ßas (*short reads*) mais complicado ser√° o processo de montagem
2. Pe√ßas maiores (*long reads*) facilitam o processo de montagem
3. Pode ser usado um molde (genoma de refer√™cia) por√©m deve ser **muito** pr√≥ximo.
4. Um genoma de refer√™ncia "distante" gera montagens errados
5. Genomas com alta porcentagem de repeti√ß√µes s√£o mais dif√≠ceis de montar.

---
## Programas para montagem de genomas


* Megahit (sequ√™ncias curtas)
* Spades (sequ√™ncias curtas e longas)
* Canu (sequ√™ncias longas)
* Velvet, SOAP, IDBA, etc.

---
## Como avaliar a qualidade da montagem?

1. N√∫mero de contigs 
2. Tamanho dos contigs
3. Tamanho do maior contig
4. N50
5. Tamanho total da montagem
6. Completude/ Contamina√ß√£o

<font size=3> Programa para avaliar a montagem, QUAST (1-5), BUSCO/CheckM (6) </font>

---
## N50

50% do total de bp que est√£o no 50% dos contigs.

**Exemplo**

Um genoma de 300 Mbp fou montado em 8 contigs. Os tamanhos dos contigs s√£o: 15 Mbp, 39 Mbp, 24 Mbp, 3 Mbp, 33 Mbp, 45 Mbp, 117 Mbp e 54 Mbp.

1. Ordene de maior a menor os tamanhos dos contigs

> 117, 54, 45, 39, 33, 24, 15, 3, 3

2. Calcule a metade do genoma

> 150 Mbp

3. Some os contigs at√© passar de 150 Mbp, o tamanho desse contig √© o N50
> 54 Mbp

---
class: center, middle, inverse

# Tempo para colocar en pr√°ctica!
.center[
![](https://media.giphy.com/media/Wsju5zAb5kcOfxJV9i/giphy.gif)
]
---

## Pr√°ctica II

**Conte√∫do**
* Montagem do genoma com Spades
* Avalia√ß√£o da qualidade da montagem com Quast e CheckM


```{r, echo=FALSE, fig.align = 'center', out.width = "50%"}
knitr::include_graphics("03.Images/workflow.png")
```

[**Pr√°tica**](https://github.com/khidalgo85/CURSO_SENAI/tree/master#2-montagem-de-novo)
<<<<<<< HEAD
=======

>>>>>>> e55d08db7c7362d5db107eb40b4dc556668ae3f0
